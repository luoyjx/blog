---
slug: 547b253437d1eb3f6c3813a0
title: Javascript设计模式初探——概念
tags: [javascript ,设计模式]
---

#### 起因 

&nbsp; &nbsp; 最近在开发当做用Javascript比较多，特别是在用nodejs开发公司的项目中使用的通讯服务器，由于之前没有类似经验，也只能慢慢摸索，由于整个项目由最先开始的仅有socket服务扩展到，需要http服务器，外加websocket等等。让我开始觉得在系统的设计上很是乱，不清晰。目前还仅仅只是根据各个部分的完成的任务不同来大体分成那么些模块，而且各个模块间的耦合度也还没达到理想的情况。Nodejs中有所谓的模块和包的概念应该是不希望这样的事情发生的，所以左思右想还是决定学习下设计模式，毕竟设计模式是前人总结出来的成熟的设计方法。 

&nbsp; &nbsp; 对比之后先买了本动物园系列的《Javascript设计模式》，浏览了下目录，前面的基本的设计模式，和以往java等语言的设计模式要差不多，都是那么些，不过以Javascript的示例展现出来要更接近我的意愿。毕竟Javascript的一些机制和常见语言稍显不同。 

#### 概览 

&nbsp; &nbsp; 首先大致浏览下根据功能不同来划分的一些设计模式吧。以下几种： 

1. &nbsp; &nbsp;&nbsp; 创建型设计模式
1. &nbsp; &nbsp; 结构型设计模式
1. &nbsp; &nbsp; 行为设计模式

&nbsp; &nbsp; **创建型：**

* &nbsp; &nbsp; Constructor(构造器)
* &nbsp; &nbsp; Factory(工厂)
* &nbsp; &nbsp; Abstract(抽象)
* &nbsp; &nbsp; Prototype(原型)
* &nbsp; &nbsp; Singleton(单例)
* &nbsp; &nbsp; Builder(生成器)

&nbsp; &nbsp; **结构型：**

* &nbsp; &nbsp; Decorator(装饰者)
* &nbsp; &nbsp; Facade(外观)
* &nbsp; &nbsp; Flyweight(享元)
* &nbsp; &nbsp; Adapter(适配器) &nbsp; &nbsp;&nbsp;
* &nbsp; &nbsp; Proxy(代理)

&nbsp; &nbsp; **行为型：**

* &nbsp; &nbsp; Iterator(迭代器)
* &nbsp; &nbsp; Mediator(中介者)
* &nbsp; &nbsp; Observer(观察者) &nbsp;&nbsp;
* &nbsp; &nbsp; Visitor(访问者)

&nbsp; &nbsp; 知道了大概都有这么一些设计模式，确实有点头大，有几个模式还是略微熟悉的，工厂模式、单例模式啦在java中见到的比较多。 

&nbsp; &nbsp; 不过其他的从字面还是不怎么理解，一步一步来学习。 

&nbsp; &nbsp; 有这么一个表格，大致的阐述了设计模式。还是分成这三类。 

&nbsp; &nbsp; **创建型模式****&nbsp;&nbsp;&nbsp;&nbsp;****&nbsp;&nbsp;&nbsp;&nbsp;****&nbsp;&nbsp;&nbsp;&nbsp;****&nbsp; 基于创建对象的概念**

&nbsp; &nbsp; 工厂方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;基于接口数据或事件生成几个派生类的实例 

&nbsp; &nbsp; 抽象工厂&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;创建若干类系列的一个实例，无需详述具体的类 

&nbsp; &nbsp; 生成器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; 从表示中分离对象构建：总是创建相同类型的对象 

&nbsp; &nbsp; 原型&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;用于复制或克隆完全初始化的实例 

&nbsp; &nbsp; 单例&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;一个类在全局访问点只有唯一一个实例 

&nbsp; &nbsp;&nbsp; 

**&nbsp; &nbsp; 结构型****&nbsp;&nbsp;&nbsp;&nbsp;****&nbsp;&nbsp;&nbsp;&nbsp;****&nbsp;&nbsp;&nbsp;&nbsp;****&nbsp;&nbsp;&nbsp;&nbsp;****&nbsp;&nbsp;&nbsp;&nbsp;****&nbsp;基于构建对象块的想法**

&nbsp; &nbsp; 适配器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 匹配不同类的接口，因此类可以在不兼容接口的情况下共同工作 

&nbsp; &nbsp; 桥接&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;将对象接口从其实现中分离，因此它们可以独立进行变化 

&nbsp; &nbsp; 组合&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;简单和复合对象的结构，使对象的总和不只是它各部分的总和 

&nbsp; &nbsp; 装饰&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;向对象动态的添加备选的处理 

&nbsp; &nbsp; 外观&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;隐藏整个子系统复杂性的唯一一个类 

&nbsp; &nbsp; 享元&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;一个用于实现包含在别处信息的高效共享的细粒度实例 

&nbsp; &nbsp; 代理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;占位符对象代表真正的对象 

&nbsp;&nbsp;&nbsp;&nbsp; 

**&nbsp; &nbsp; 行为模式****&nbsp;&nbsp;&nbsp;&nbsp;****&nbsp;&nbsp;&nbsp;&nbsp;****&nbsp;&nbsp;&nbsp;&nbsp;****&nbsp;&nbsp;&nbsp;&nbsp;****&nbsp; 基于对象在一起配合工作的方式**

&nbsp; &nbsp; 解释器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; 将语言元素包含在应用程序中的方法，以匹配预期语言的语法 

&nbsp; &nbsp; 模板方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;在方法中创建算法的shell，然后将确切的步骤推到子类 

&nbsp; &nbsp; 职责链&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; 在对象链之间传递请求的方法，以找到能够处理请求的对象 

&nbsp; &nbsp; 命令&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;将命令执行从其调用程序中分离的方法 

&nbsp; &nbsp; 迭代器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; 顺序访问一个集合中的元素，无需了解该集合的内部工作原理 

&nbsp; &nbsp; 中介者&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; 在类之间定义简化的通信，以防止一组类显示引用彼此 

&nbsp; &nbsp; 备忘录&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; 捕获对象的内部状态，以能够在以后恢复它 

&nbsp; &nbsp; 观察者&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 向多个类通知改变的方式，以确保类之间的一致性 

&nbsp; &nbsp; 状态&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;状态改变时，更改对象行为 

&nbsp; &nbsp; 策略&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;在一个类中封装算法，将选择与实现分离 

&nbsp; &nbsp; 访问者&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 向类添加一个新的操作，无需改变类 

&nbsp;&nbsp;&nbsp;&nbsp; 

&nbsp;&nbsp;&nbsp;&nbsp;到此，我们对设计模式有了一个初步的印象。 


